{"version":3,"sources":["Carousel.tsx"],"names":["defaultTimingConfig","duration","Carousel","props","ref","height","data","_data","width","loop","mode","renderItem","autoPlay","autoPlayReverse","autoPlayInterval","parallaxScrollingOffset","parallaxScrollingScale","onScrollBegin","onSnapToItem","style","timingConfig","lockController","handlerOffsetX","React","useMemo","length","computedAnimResult","indexController","originalLength","onChange","i","index","sharedPreIndex","sharedIndex","computedIndex","onScrollEnd","useCallback","current","carouselController","disable","offsetX","x","value","WL","isNaN","next","prev","getCurrentIndex","goToIndex","animated","to","animatedListScrollHandler","onStart","_","ctx","isLock","startContentOffsetX","currentContentOffsetX","start","onActive","e","translationX","Math","max","min","onEnd","_withTimingCallback","num","isFinished","unLock","lock","abs","velocityX","useImperativeHandle","Layouts","children","flexDirection","position","map","item","forwardRef"],"mappings":";;;;;;;AAAA;;AAEA;;AAIA;;AAOA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAEA,MAAMA,mBAA8C,GAAG;AACnDC,EAAAA,QAAQ,EAAE;AADyC,CAAvD;;AAkGA,SAASC,QAAT,CACIC,KADJ,EAEIC,GAFJ,EAGE;AACE,QAAM;AACFC,IAAAA,MAAM,GAAG,MADP;AAEFC,IAAAA,IAAI,EAAEC,KAAK,GAAG,EAFZ;AAGFC,IAAAA,KAHE;AAIFC,IAAAA,IAAI,GAAG,IAJL;AAKFC,IAAAA,IAAI,GAAG,SALL;AAMFC,IAAAA,UANE;AAOFC,IAAAA,QAPE;AAQFC,IAAAA,eARE;AASFC,IAAAA,gBATE;AAUFC,IAAAA,uBAVE;AAWFC,IAAAA,sBAXE;AAYFC,IAAAA,aAAa,GAAG,MAAM,CAAE,CAZtB;AAaFC,IAAAA,YAbE;AAcFC,IAAAA,KAdE;AAeFC,IAAAA,YAAY,GAAGpB;AAfb,MAgBFG,KAhBJ;AAiBA,QAAMkB,cAAc,GAAG,iCAAvB;AACA,QAAMC,cAAc,GAAG,2CAAuB,CAAvB,CAAvB;;AACA,QAAMhB,IAAI,GAAGiB,eAAMC,OAAN,CAAmB,MAAM;AAClC,QAAI,CAACf,IAAL,EAAW,OAAOF,KAAP;;AAEX,QAAIA,KAAK,CAACkB,MAAN,KAAiB,CAArB,EAAwB;AACpB,aAAO,CAAClB,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqBA,KAAK,CAAC,CAAD,CAA1B,CAAP;AACH;;AAED,QAAIA,KAAK,CAACkB,MAAN,KAAiB,CAArB,EAAwB;AACpB,aAAO,CAAClB,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqBA,KAAK,CAAC,CAAD,CAA1B,EAA+BA,KAAK,CAAC,CAAD,CAApC,CAAP;AACH;;AAED,WAAOA,KAAP;AACH,GAZY,EAYV,CAACA,KAAD,EAAQE,IAAR,CAZU,CAAb;;AAcA,QAAMiB,kBAAkB,GAAG,sCAAgBlB,KAAhB,EAAuBF,IAAI,CAACmB,MAA5B,CAA3B;AAEA,QAAME,eAAe,GAAG,4CAAmB;AACvCC,IAAAA,cAAc,EAAErB,KAAK,CAACkB,MADiB;AAEvCA,IAAAA,MAAM,EAAEnB,IAAI,CAACmB,MAF0B;AAGvCH,IAAAA,cAHuC;AAIvCd,IAAAA,KAJuC;AAKvCC,IAAAA,IALuC;AAMvCoB,IAAAA,QAAQ,EAAGC,CAAD,IAAOZ,YAAY,IAAI,oCAAQA,YAAR,EAAsBY,CAAtB;AANM,GAAnB,CAAxB;AASA,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA,cAAT;AAAyBC,IAAAA,WAAzB;AAAsCC,IAAAA;AAAtC,MACFP,eADJ;;AAGA,QAAMQ,WAAW,GAAGZ,eAAMa,WAAN,CAAkB,MAAM;AAAA;;AACxCF,IAAAA,aAAa;AACb,0BAAA/B,KAAK,CAACgC,WAAN,+EAAAhC,KAAK,EAAe6B,cAAc,CAACK,OAA9B,EAAuCJ,WAAW,CAACI,OAAnD,CAAL;AACH,GAHmB,EAGjB,CAACL,cAAD,EAAiBC,WAAjB,EAA8BC,aAA9B,EAA6C/B,KAA7C,CAHiB,CAApB;;AAKA,QAAMmC,kBAAkB,GAAG,kDAAsB;AAC7C7B,IAAAA,IAD6C;AAE7CD,IAAAA,KAF6C;AAG7Cc,IAAAA,cAH6C;AAI7CK,IAAAA,eAJ6C;AAK7CN,IAAAA,cAL6C;AAM7CD,IAAAA,YAN6C;AAO7CmB,IAAAA,OAAO,EAAE,CAACjC,IAAI,CAACmB,MAP8B;AAQ7CR,IAAAA,aAAa,EAAE,MAAM,oCAAQA,aAAR,GARwB;AAS7CkB,IAAAA,WAAW,EAAE,MAAM,oCAAQA,WAAR;AAT0B,GAAtB,CAA3B;AAYA,QAAMK,OAAO,GAAG,4CAAgB,MAAM;AAClC,UAAMC,CAAC,GAAGnB,cAAc,CAACoB,KAAf,GAAuBhB,kBAAkB,CAACiB,EAApD;AACA,WAAOC,KAAK,CAACH,CAAD,CAAL,GAAW,CAAX,GAAeA,CAAtB;AACH,GAHe,EAGb,CAACf,kBAAD,CAHa,CAAhB;AAKA,gCAAY;AACRd,IAAAA,QADQ;AAERE,IAAAA,gBAFQ;AAGRD,IAAAA,eAHQ;AAIRyB,IAAAA,kBAJQ;AAKRjB,IAAAA;AALQ,GAAZ;;AAQA,QAAMwB,IAAI,GAAGtB,eAAMa,WAAN,CAAkB,MAAM;AACjC,WAAOE,kBAAkB,CAACO,IAAnB,EAAP;AACH,GAFY,EAEV,CAACP,kBAAD,CAFU,CAAb;;AAIA,QAAMQ,IAAI,GAAGvB,eAAMa,WAAN,CAAkB,MAAM;AACjC,WAAOE,kBAAkB,CAACQ,IAAnB,EAAP;AACH,GAFY,EAEV,CAACR,kBAAD,CAFU,CAAb;;AAIA,QAAMS,eAAe,GAAGxB,eAAMa,WAAN,CAAkB,MAAM;AAC5C,WAAOL,KAAK,CAACW,KAAb;AACH,GAFuB,EAErB,CAACX,KAAD,CAFqB,CAAxB;;AAIA,QAAMiB,SAAS,GAAGzB,eAAMa,WAAN,CACd,CAACN,CAAD,EAAYmB,QAAZ,KAAmC;AAC/BX,IAAAA,kBAAkB,CAACY,EAAnB,CAAsBpB,CAAtB,EAAyBmB,QAAzB;AACH,GAHa,EAId,CAACX,kBAAD,CAJc,CAAlB;;AAOA,QAAMa,yBAAyB,GAC3B,sDACI;AACIC,IAAAA,OAAO,EAAE,CAACC,CAAD,EAAIC,GAAJ,KAAiB;AACtB,UAAIjC,cAAc,CAACkC,MAAf,EAAJ,EAA6B;AAC7B,0CAAQtC,aAAR;AACAqC,MAAAA,GAAG,CAACE,mBAAJ,GAA0BlC,cAAc,CAACoB,KAAzC;AACAY,MAAAA,GAAG,CAACG,qBAAJ,GAA4BnC,cAAc,CAACoB,KAA3C;AACAY,MAAAA,GAAG,CAACI,KAAJ,GAAY,IAAZ;AACH,KAPL;AAQIC,IAAAA,QAAQ,EAAE,CAACC,CAAD,EAAIN,GAAJ,KAAiB;AACvB,UAAIjC,cAAc,CAACkC,MAAf,MAA2B,CAACD,GAAG,CAACI,KAApC,EAA2C;AAC3C;AACpB;AACA;;AACoBJ,MAAAA,GAAG,CAACO,YAAJ,GAAmBD,CAAC,CAACC,YAArB;;AACA,UAAIpD,IAAJ,EAAU;AACNa,QAAAA,cAAc,CAACoB,KAAf,GACIY,GAAG,CAACG,qBAAJ,GAA4BG,CAAC,CAACC,YADlC;AAEA;AACH;;AACDvC,MAAAA,cAAc,CAACoB,KAAf,GAAuBoB,IAAI,CAACC,GAAL,CACnBD,IAAI,CAACE,GAAL,CAASV,GAAG,CAACG,qBAAJ,GAA4BG,CAAC,CAACC,YAAvC,EAAqD,CAArD,CADmB,EAEnB,EAAEvD,IAAI,CAACmB,MAAL,GAAc,CAAhB,IAAqBjB,KAFF,CAAvB;AAIH,KAvBL;AAwBIyD,IAAAA,KAAK,EAAE,CAACL,CAAD,EAAIN,GAAJ,KAAiB;AACpB,UAAIjC,cAAc,CAACkC,MAAf,MAA2B,CAACD,GAAG,CAACI,KAApC,EAA2C;AAC3C,YAAMG,YAAY,GAAGP,GAAG,CAACO,YAAzB;;AACA,eAASK,mBAAT,CAA6BC,GAA7B,EAA0C;AACtC,eAAO,uCAAWA,GAAX,EAAgB/C,YAAhB,EAA+BgD,UAAD,IAAgB;AACjD,cAAIA,UAAJ,EAAgB;AACZd,YAAAA,GAAG,CAACI,KAAJ,GAAY,KAAZ;AACArC,YAAAA,cAAc,CAACgD,MAAf;AACA,gDAAQlC,WAAR;AACH;AACJ,SANM,CAAP;AAOH;;AAED,UAAI0B,YAAY,GAAG,CAAnB,EAAsB;AAClB;AACxB;AACA;AACwB,YAAI,CAACpD,IAAD,IAASa,cAAc,CAACoB,KAAf,IAAwB,CAArC,EAAwC;AACpC;AACH;;AACDrB,QAAAA,cAAc,CAACiD,IAAf;;AACA,YACIR,IAAI,CAACS,GAAL,CAASV,YAAT,IAAyBC,IAAI,CAACS,GAAL,CAASX,CAAC,CAACY,SAAX,CAAzB,GACAhE,KAAK,GAAG,CAFZ,EAGE;AACEc,UAAAA,cAAc,CAACoB,KAAf,GAAuBwB,mBAAmB,CACtC5C,cAAc,CAACoB,KAAf,GAAuBlC,KAAvB,GAA+BqD,YADO,CAA1C;AAGH,SAPD,MAOO;AACHvC,UAAAA,cAAc,CAACoB,KAAf,GAAuBwB,mBAAmB,CACtC5C,cAAc,CAACoB,KAAf,GAAuBmB,YADe,CAA1C;AAGH;;AACD;AACH;;AAED,UAAIA,YAAY,GAAG,CAAnB,EAAsB;AAClB;AACxB;AACA;AACwB,YACI,CAACpD,IAAD,IACAa,cAAc,CAACoB,KAAf,IAAwB,EAAEpC,IAAI,CAACmB,MAAL,GAAc,CAAhB,IAAqBjB,KAFjD,EAGE;AACE;AACH;;AACDa,QAAAA,cAAc,CAACiD,IAAf;;AACA,YACIR,IAAI,CAACS,GAAL,CAASV,YAAT,IAAyBC,IAAI,CAACS,GAAL,CAASX,CAAC,CAACY,SAAX,CAAzB,GACAhE,KAAK,GAAG,CAFZ,EAGE;AACEc,UAAAA,cAAc,CAACoB,KAAf,GAAuBwB,mBAAmB,CACtC5C,cAAc,CAACoB,KAAf,GAAuBlC,KAAvB,GAA+BqD,YADO,CAA1C;AAGH,SAPD,MAOO;AACHvC,UAAAA,cAAc,CAACoB,KAAf,GAAuBwB,mBAAmB,CACtC5C,cAAc,CAACoB,KAAf,GAAuBmB,YADe,CAA1C;AAGH;;AACD;AACH;AACJ;AArFL,GADJ,EAwFI,CAACpD,IAAD,EAAOH,IAAP,EAAae,cAAb,EAA6BJ,aAA7B,EAA4CkB,WAA5C,CAxFJ,CADJ;;AA4FAZ,iBAAMkD,mBAAN,CAA0BrE,GAA1B,EAA+B,MAAM;AACjC,WAAO;AACHyC,MAAAA,IADG;AAEHC,MAAAA,IAFG;AAGHC,MAAAA,eAHG;AAIHC,MAAAA;AAJG,KAAP;AAMH,GAPD;;AASA,QAAM0B,OAAO,GAAGnD,eAAMC,OAAN,CAA2C,MAAM;AAC7D,YAAQd,IAAR;AACI,WAAK,UAAL;AACI,eAAO,CAAC;AAAEqB,UAAAA,KAAK,EAAED,CAAT;AAAY6C,UAAAA;AAAZ,SAAD,kBACH,6BAAC,qBAAD;AACI,UAAA,uBAAuB,EAAE5D,uBAD7B;AAEI,UAAA,sBAAsB,EAAEC,sBAF5B;AAGI,UAAA,kBAAkB,EAAEU,kBAHxB;AAII,UAAA,KAAK,EAAElB,KAJX;AAKI,UAAA,cAAc,EAAEgC,OALpB;AAMI,UAAA,KAAK,EAAEV,CANX;AAOI,UAAA,GAAG,EAAEA,CAPT;AAQI,UAAA,IAAI,EAAErB;AARV,WAUKkE,QAVL,CADJ;;AAcJ;AACI,eAAO,CAAC;AAAE5C,UAAAA,KAAK,EAAED,CAAT;AAAY6C,UAAAA;AAAZ,SAAD,kBACH,6BAAC,0BAAD;AACI,UAAA,kBAAkB,EAAEjD,kBADxB;AAEI,UAAA,KAAK,EAAElB,KAFX;AAGI,UAAA,MAAM,EAAEH,MAHZ;AAII,UAAA,cAAc,EAAEmC,OAJpB;AAKI,UAAA,KAAK,EAAEV,CALX;AAMI,UAAA,GAAG,EAAEA,CANT;AAOI,UAAA,IAAI,EAAErB;AAPV,WASKkE,QATL,CADJ;AAjBR;AA+BH,GAhCe,EAgCb,CACClE,IADD,EAECC,IAFD,EAGCgB,kBAHD,EAICrB,MAJD,EAKCmC,OALD,EAMCzB,uBAND,EAOCC,sBAPD,EAQCR,KARD,CAhCa,CAAhB;;AA2CA,sBACI,6BAAC,4CAAD;AAAmB,IAAA,oBAAoB,EAAE2C;AAAzC,kBACI,6BAAC,8BAAD,CAAU,IAAV;AACI,IAAA,KAAK,EAAE,CACH;AACA;AACI3C,MAAAA,KADJ;AAEIH,MAAAA,MAFJ;AAGIuE,MAAAA,aAAa,EAAE,KAHnB;AAIIC,MAAAA,QAAQ,EAAE;AAJd,KAFG,EAQH1D,KARG;AADX,KAYKb,IAAI,CAACwE,GAAL,CAAS,CAACC,IAAD,EAAOjD,CAAP,KAAa;AACnB,wBACI,6BAAC,OAAD;AAAS,MAAA,KAAK,EAAEA,CAAhB;AAAmB,MAAA,GAAG,EAAEA;AAAxB,OACKnB,UAAU,CAACoE,IAAD,EAAOjD,CAAP,CADf,CADJ;AAKH,GANA,CAZL,CADJ,CADJ;AAwBH;;4BAEcP,eAAMyD,UAAN,CAAiB9E,QAAjB,C","sourcesContent":["import React from 'react';\nimport type { FlexStyle, ViewStyle } from 'react-native';\nimport {\n    PanGestureHandler,\n    PanGestureHandlerGestureEvent,\n} from 'react-native-gesture-handler';\nimport Animated, {\n    runOnJS,\n    useAnimatedGestureHandler,\n    useDerivedValue,\n    useSharedValue,\n    withTiming,\n} from 'react-native-reanimated';\nimport { CarouselItem } from './CarouselItem';\nimport type { TMode } from './layouts';\nimport { ParallaxLayout } from './layouts/index';\nimport { useCarouselController } from './useCarouselController';\nimport { useComputedAnim } from './useComputedAnim';\nimport { useAutoPlay } from './useAutoPlay';\nimport { useIndexController } from './useIndexController';\nimport { useLockController } from './useLock';\n\nconst defaultTimingConfig: Animated.WithTimingConfig = {\n    duration: 250,\n};\n\nexport interface ICarouselProps<T extends unknown> {\n    ref?: React.Ref<ICarouselInstance>;\n    /**\n     * Carousel loop playback.\n     * @default true\n     */\n    loop?: boolean;\n    /**\n     * Carousel Animated transitions.\n     * @default 'default'\n     */\n    mode?: TMode;\n    /**\n     * Render carousel item.\n     */\n    renderItem: (data: T, index: number) => React.ReactNode;\n    /**\n     * Specified carousel container width.\n     */\n    width: number;\n    /**\n     * Specified carousel container height.\n     * @default '100%'\n     */\n    height?: FlexStyle['height'];\n    /**\n     * Carousel items data set.\n     */\n    data: T[];\n    /**\n     * Auto play\n     */\n    autoPlay?: boolean;\n    /**\n     * Auto play\n     * @description reverse playback\n     */\n    autoPlayReverse?: boolean;\n    /**\n     * Auto play\n     * @description playback interval\n     */\n    autoPlayInterval?: number;\n    /**\n     * Carousel container style\n     */\n    style?: ViewStyle;\n    /**\n     * When use 'default' Layout props,this prop can be control prev/next item offset.\n     * @default 100\n     */\n    parallaxScrollingOffset?: number;\n    /**\n     * When use 'default' Layout props,this prop can be control prev/next item offset.\n     * @default 0.8\n     */\n    parallaxScrollingScale?: number;\n    /**\n     * Callback fired when navigating to an item\n     */\n    onSnapToItem?: (index: number) => void;\n    /**\n     * Timing config of translation animated\n     */\n    timingConfig?: Animated.WithTimingConfig;\n    /**\n     * On scroll begin\n     */\n    onScrollBegin?: () => void;\n    /**\n     * On scroll end\n     */\n    onScrollEnd?: (previous: number, current: number) => void;\n}\n\nexport interface ICarouselInstance {\n    /**\n     * Play the last one\n     */\n    prev: () => void;\n    /**\n     * Play the next one\n     */\n    next: () => void;\n    /**\n     * Get current item index\n     */\n    getCurrentIndex: () => number;\n    /**\n     * Go to index\n     */\n    goToIndex: (index: number, animated?: boolean) => void;\n}\n\nfunction Carousel<T extends unknown = any>(\n    props: ICarouselProps<T>,\n    ref: React.Ref<ICarouselInstance>\n) {\n    const {\n        height = '100%',\n        data: _data = [],\n        width,\n        loop = true,\n        mode = 'default',\n        renderItem,\n        autoPlay,\n        autoPlayReverse,\n        autoPlayInterval,\n        parallaxScrollingOffset,\n        parallaxScrollingScale,\n        onScrollBegin = () => {},\n        onSnapToItem,\n        style,\n        timingConfig = defaultTimingConfig,\n    } = props;\n    const lockController = useLockController();\n    const handlerOffsetX = useSharedValue<number>(0);\n    const data = React.useMemo<T[]>(() => {\n        if (!loop) return _data;\n\n        if (_data.length === 1) {\n            return [_data[0], _data[0], _data[0]];\n        }\n\n        if (_data.length === 2) {\n            return [_data[0], _data[1], _data[0], _data[1]];\n        }\n\n        return _data;\n    }, [_data, loop]);\n\n    const computedAnimResult = useComputedAnim(width, data.length);\n\n    const indexController = useIndexController({\n        originalLength: _data.length,\n        length: data.length,\n        handlerOffsetX,\n        width,\n        loop,\n        onChange: (i) => onSnapToItem && runOnJS(onSnapToItem)(i),\n    });\n\n    const { index, sharedPreIndex, sharedIndex, computedIndex } =\n        indexController;\n\n    const onScrollEnd = React.useCallback(() => {\n        computedIndex();\n        props.onScrollEnd?.(sharedPreIndex.current, sharedIndex.current);\n    }, [sharedPreIndex, sharedIndex, computedIndex, props]);\n\n    const carouselController = useCarouselController({\n        loop,\n        width,\n        handlerOffsetX,\n        indexController,\n        lockController,\n        timingConfig,\n        disable: !data.length,\n        onScrollBegin: () => runOnJS(onScrollBegin)(),\n        onScrollEnd: () => runOnJS(onScrollEnd)(),\n    });\n\n    const offsetX = useDerivedValue(() => {\n        const x = handlerOffsetX.value % computedAnimResult.WL;\n        return isNaN(x) ? 0 : x;\n    }, [computedAnimResult]);\n\n    useAutoPlay({\n        autoPlay,\n        autoPlayInterval,\n        autoPlayReverse,\n        carouselController,\n        lockController,\n    });\n\n    const next = React.useCallback(() => {\n        return carouselController.next();\n    }, [carouselController]);\n\n    const prev = React.useCallback(() => {\n        return carouselController.prev();\n    }, [carouselController]);\n\n    const getCurrentIndex = React.useCallback(() => {\n        return index.value;\n    }, [index]);\n\n    const goToIndex = React.useCallback(\n        (i: number, animated?: boolean) => {\n            carouselController.to(i, animated);\n        },\n        [carouselController]\n    );\n\n    const animatedListScrollHandler =\n        useAnimatedGestureHandler<PanGestureHandlerGestureEvent>(\n            {\n                onStart: (_, ctx: any) => {\n                    if (lockController.isLock()) return;\n                    runOnJS(onScrollBegin)();\n                    ctx.startContentOffsetX = handlerOffsetX.value;\n                    ctx.currentContentOffsetX = handlerOffsetX.value;\n                    ctx.start = true;\n                },\n                onActive: (e, ctx: any) => {\n                    if (lockController.isLock() || !ctx.start) return;\n                    /**\n                     * `onActive` and `onEnd` return different values of translationX！So that creates a bias！TAT\n                     * */\n                    ctx.translationX = e.translationX;\n                    if (loop) {\n                        handlerOffsetX.value =\n                            ctx.currentContentOffsetX + e.translationX;\n                        return;\n                    }\n                    handlerOffsetX.value = Math.max(\n                        Math.min(ctx.currentContentOffsetX + e.translationX, 0),\n                        -(data.length - 1) * width\n                    );\n                },\n                onEnd: (e, ctx: any) => {\n                    if (lockController.isLock() || !ctx.start) return;\n                    const translationX = ctx.translationX;\n                    function _withTimingCallback(num: number) {\n                        return withTiming(num, timingConfig, (isFinished) => {\n                            if (isFinished) {\n                                ctx.start = false;\n                                lockController.unLock();\n                                runOnJS(onScrollEnd)();\n                            }\n                        });\n                    }\n\n                    if (translationX > 0) {\n                        /**\n                         * If not loop no , longer scroll when sliding to the start.\n                         * */\n                        if (!loop && handlerOffsetX.value >= 0) {\n                            return;\n                        }\n                        lockController.lock();\n                        if (\n                            Math.abs(translationX) + Math.abs(e.velocityX) >\n                            width / 2\n                        ) {\n                            handlerOffsetX.value = _withTimingCallback(\n                                handlerOffsetX.value + width - translationX\n                            );\n                        } else {\n                            handlerOffsetX.value = _withTimingCallback(\n                                handlerOffsetX.value - translationX\n                            );\n                        }\n                        return;\n                    }\n\n                    if (translationX < 0) {\n                        /**\n                         * If not loop , no longer scroll when sliding to the end.\n                         * */\n                        if (\n                            !loop &&\n                            handlerOffsetX.value <= -(data.length - 1) * width\n                        ) {\n                            return;\n                        }\n                        lockController.lock();\n                        if (\n                            Math.abs(translationX) + Math.abs(e.velocityX) >\n                            width / 2\n                        ) {\n                            handlerOffsetX.value = _withTimingCallback(\n                                handlerOffsetX.value - width - translationX\n                            );\n                        } else {\n                            handlerOffsetX.value = _withTimingCallback(\n                                handlerOffsetX.value - translationX\n                            );\n                        }\n                        return;\n                    }\n                },\n            },\n            [loop, data, lockController, onScrollBegin, onScrollEnd]\n        );\n\n    React.useImperativeHandle(ref, () => {\n        return {\n            next,\n            prev,\n            getCurrentIndex,\n            goToIndex,\n        };\n    });\n\n    const Layouts = React.useMemo<React.FC<{ index: number }>>(() => {\n        switch (mode) {\n            case 'parallax':\n                return ({ index: i, children }) => (\n                    <ParallaxLayout\n                        parallaxScrollingOffset={parallaxScrollingOffset}\n                        parallaxScrollingScale={parallaxScrollingScale}\n                        computedAnimResult={computedAnimResult}\n                        width={width}\n                        handlerOffsetX={offsetX}\n                        index={i}\n                        key={i}\n                        loop={loop}\n                    >\n                        {children}\n                    </ParallaxLayout>\n                );\n            default:\n                return ({ index: i, children }) => (\n                    <CarouselItem\n                        computedAnimResult={computedAnimResult}\n                        width={width}\n                        height={height}\n                        handlerOffsetX={offsetX}\n                        index={i}\n                        key={i}\n                        loop={loop}\n                    >\n                        {children}\n                    </CarouselItem>\n                );\n        }\n    }, [\n        loop,\n        mode,\n        computedAnimResult,\n        height,\n        offsetX,\n        parallaxScrollingOffset,\n        parallaxScrollingScale,\n        width,\n    ]);\n\n    return (\n        <PanGestureHandler onHandlerStateChange={animatedListScrollHandler}>\n            <Animated.View\n                style={[\n                    // eslint-disable-next-line react-native/no-inline-styles\n                    {\n                        width,\n                        height,\n                        flexDirection: 'row',\n                        position: 'relative',\n                    },\n                    style,\n                ]}\n            >\n                {data.map((item, i) => {\n                    return (\n                        <Layouts index={i} key={i}>\n                            {renderItem(item, i)}\n                        </Layouts>\n                    );\n                })}\n            </Animated.View>\n        </PanGestureHandler>\n    );\n}\n\nexport default React.forwardRef(Carousel) as typeof Carousel;\n"]}