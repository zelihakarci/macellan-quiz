"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactNativeGestureHandler = require("react-native-gesture-handler");

var _reactNativeReanimated = _interopRequireWildcard(require("react-native-reanimated"));

var _CarouselItem = require("./CarouselItem");

var _index = require("./layouts/index");

var _useCarouselController = require("./useCarouselController");

var _useComputedAnim = require("./useComputedAnim");

var _useAutoPlay = require("./useAutoPlay");

var _useIndexController = require("./useIndexController");

var _useLock = require("./useLock");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultTimingConfig = {
  duration: 250
};

function Carousel(props, ref) {
  const {
    height = '100%',
    data: _data = [],
    width,
    loop = true,
    mode = 'default',
    renderItem,
    autoPlay,
    autoPlayReverse,
    autoPlayInterval,
    parallaxScrollingOffset,
    parallaxScrollingScale,
    onScrollBegin = () => {},
    onSnapToItem,
    style,
    timingConfig = defaultTimingConfig
  } = props;
  const lockController = (0, _useLock.useLockController)();
  const handlerOffsetX = (0, _reactNativeReanimated.useSharedValue)(0);

  const data = _react.default.useMemo(() => {
    if (!loop) return _data;

    if (_data.length === 1) {
      return [_data[0], _data[0], _data[0]];
    }

    if (_data.length === 2) {
      return [_data[0], _data[1], _data[0], _data[1]];
    }

    return _data;
  }, [_data, loop]);

  const computedAnimResult = (0, _useComputedAnim.useComputedAnim)(width, data.length);
  const indexController = (0, _useIndexController.useIndexController)({
    originalLength: _data.length,
    length: data.length,
    handlerOffsetX,
    width,
    loop,
    onChange: i => onSnapToItem && (0, _reactNativeReanimated.runOnJS)(onSnapToItem)(i)
  });
  const {
    index,
    sharedPreIndex,
    sharedIndex,
    computedIndex
  } = indexController;

  const onScrollEnd = _react.default.useCallback(() => {
    var _props$onScrollEnd;

    computedIndex();
    (_props$onScrollEnd = props.onScrollEnd) === null || _props$onScrollEnd === void 0 ? void 0 : _props$onScrollEnd.call(props, sharedPreIndex.current, sharedIndex.current);
  }, [sharedPreIndex, sharedIndex, computedIndex, props]);

  const carouselController = (0, _useCarouselController.useCarouselController)({
    loop,
    width,
    handlerOffsetX,
    indexController,
    lockController,
    timingConfig,
    disable: !data.length,
    onScrollBegin: () => (0, _reactNativeReanimated.runOnJS)(onScrollBegin)(),
    onScrollEnd: () => (0, _reactNativeReanimated.runOnJS)(onScrollEnd)()
  });
  const offsetX = (0, _reactNativeReanimated.useDerivedValue)(() => {
    const x = handlerOffsetX.value % computedAnimResult.WL;
    return isNaN(x) ? 0 : x;
  }, [computedAnimResult]);
  (0, _useAutoPlay.useAutoPlay)({
    autoPlay,
    autoPlayInterval,
    autoPlayReverse,
    carouselController,
    lockController
  });

  const next = _react.default.useCallback(() => {
    return carouselController.next();
  }, [carouselController]);

  const prev = _react.default.useCallback(() => {
    return carouselController.prev();
  }, [carouselController]);

  const getCurrentIndex = _react.default.useCallback(() => {
    return index.value;
  }, [index]);

  const goToIndex = _react.default.useCallback((i, animated) => {
    carouselController.to(i, animated);
  }, [carouselController]);

  const animatedListScrollHandler = (0, _reactNativeReanimated.useAnimatedGestureHandler)({
    onStart: (_, ctx) => {
      if (lockController.isLock()) return;
      (0, _reactNativeReanimated.runOnJS)(onScrollBegin)();
      ctx.startContentOffsetX = handlerOffsetX.value;
      ctx.currentContentOffsetX = handlerOffsetX.value;
      ctx.start = true;
    },
    onActive: (e, ctx) => {
      if (lockController.isLock() || !ctx.start) return;
      /**
       * `onActive` and `onEnd` return different values of translationX！So that creates a bias！TAT
       * */

      ctx.translationX = e.translationX;

      if (loop) {
        handlerOffsetX.value = ctx.currentContentOffsetX + e.translationX;
        return;
      }

      handlerOffsetX.value = Math.max(Math.min(ctx.currentContentOffsetX + e.translationX, 0), -(data.length - 1) * width);
    },
    onEnd: (e, ctx) => {
      if (lockController.isLock() || !ctx.start) return;
      const translationX = ctx.translationX;

      function _withTimingCallback(num) {
        return (0, _reactNativeReanimated.withTiming)(num, timingConfig, isFinished => {
          if (isFinished) {
            ctx.start = false;
            lockController.unLock();
            (0, _reactNativeReanimated.runOnJS)(onScrollEnd)();
          }
        });
      }

      if (translationX > 0) {
        /**
         * If not loop no , longer scroll when sliding to the start.
         * */
        if (!loop && handlerOffsetX.value >= 0) {
          return;
        }

        lockController.lock();

        if (Math.abs(translationX) + Math.abs(e.velocityX) > width / 2) {
          handlerOffsetX.value = _withTimingCallback(handlerOffsetX.value + width - translationX);
        } else {
          handlerOffsetX.value = _withTimingCallback(handlerOffsetX.value - translationX);
        }

        return;
      }

      if (translationX < 0) {
        /**
         * If not loop , no longer scroll when sliding to the end.
         * */
        if (!loop && handlerOffsetX.value <= -(data.length - 1) * width) {
          return;
        }

        lockController.lock();

        if (Math.abs(translationX) + Math.abs(e.velocityX) > width / 2) {
          handlerOffsetX.value = _withTimingCallback(handlerOffsetX.value - width - translationX);
        } else {
          handlerOffsetX.value = _withTimingCallback(handlerOffsetX.value - translationX);
        }

        return;
      }
    }
  }, [loop, data, lockController, onScrollBegin, onScrollEnd]);

  _react.default.useImperativeHandle(ref, () => {
    return {
      next,
      prev,
      getCurrentIndex,
      goToIndex
    };
  });

  const Layouts = _react.default.useMemo(() => {
    switch (mode) {
      case 'parallax':
        return ({
          index: i,
          children
        }) => /*#__PURE__*/_react.default.createElement(_index.ParallaxLayout, {
          parallaxScrollingOffset: parallaxScrollingOffset,
          parallaxScrollingScale: parallaxScrollingScale,
          computedAnimResult: computedAnimResult,
          width: width,
          handlerOffsetX: offsetX,
          index: i,
          key: i,
          loop: loop
        }, children);

      default:
        return ({
          index: i,
          children
        }) => /*#__PURE__*/_react.default.createElement(_CarouselItem.CarouselItem, {
          computedAnimResult: computedAnimResult,
          width: width,
          height: height,
          handlerOffsetX: offsetX,
          index: i,
          key: i,
          loop: loop
        }, children);
    }
  }, [loop, mode, computedAnimResult, height, offsetX, parallaxScrollingOffset, parallaxScrollingScale, width]);

  return /*#__PURE__*/_react.default.createElement(_reactNativeGestureHandler.PanGestureHandler, {
    onHandlerStateChange: animatedListScrollHandler
  }, /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    style: [// eslint-disable-next-line react-native/no-inline-styles
    {
      width,
      height,
      flexDirection: 'row',
      position: 'relative'
    }, style]
  }, data.map((item, i) => {
    return /*#__PURE__*/_react.default.createElement(Layouts, {
      index: i,
      key: i
    }, renderItem(item, i));
  })));
}

var _default = /*#__PURE__*/_react.default.forwardRef(Carousel);

exports.default = _default;
//# sourceMappingURL=Carousel.js.map