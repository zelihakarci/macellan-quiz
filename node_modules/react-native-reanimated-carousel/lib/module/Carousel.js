import React from 'react';
import { PanGestureHandler } from 'react-native-gesture-handler';
import Animated, { runOnJS, useAnimatedGestureHandler, useDerivedValue, useSharedValue, withTiming } from 'react-native-reanimated';
import { CarouselItem } from './CarouselItem';
import { ParallaxLayout } from './layouts/index';
import { useCarouselController } from './useCarouselController';
import { useComputedAnim } from './useComputedAnim';
import { useAutoPlay } from './useAutoPlay';
import { useIndexController } from './useIndexController';
import { useLockController } from './useLock';
const defaultTimingConfig = {
  duration: 250
};

function Carousel(props, ref) {
  const {
    height = '100%',
    data: _data = [],
    width,
    loop = true,
    mode = 'default',
    renderItem,
    autoPlay,
    autoPlayReverse,
    autoPlayInterval,
    parallaxScrollingOffset,
    parallaxScrollingScale,
    onScrollBegin = () => {},
    onSnapToItem,
    style,
    timingConfig = defaultTimingConfig
  } = props;
  const lockController = useLockController();
  const handlerOffsetX = useSharedValue(0);
  const data = React.useMemo(() => {
    if (!loop) return _data;

    if (_data.length === 1) {
      return [_data[0], _data[0], _data[0]];
    }

    if (_data.length === 2) {
      return [_data[0], _data[1], _data[0], _data[1]];
    }

    return _data;
  }, [_data, loop]);
  const computedAnimResult = useComputedAnim(width, data.length);
  const indexController = useIndexController({
    originalLength: _data.length,
    length: data.length,
    handlerOffsetX,
    width,
    loop,
    onChange: i => onSnapToItem && runOnJS(onSnapToItem)(i)
  });
  const {
    index,
    sharedPreIndex,
    sharedIndex,
    computedIndex
  } = indexController;
  const onScrollEnd = React.useCallback(() => {
    var _props$onScrollEnd;

    computedIndex();
    (_props$onScrollEnd = props.onScrollEnd) === null || _props$onScrollEnd === void 0 ? void 0 : _props$onScrollEnd.call(props, sharedPreIndex.current, sharedIndex.current);
  }, [sharedPreIndex, sharedIndex, computedIndex, props]);
  const carouselController = useCarouselController({
    loop,
    width,
    handlerOffsetX,
    indexController,
    lockController,
    timingConfig,
    disable: !data.length,
    onScrollBegin: () => runOnJS(onScrollBegin)(),
    onScrollEnd: () => runOnJS(onScrollEnd)()
  });
  const offsetX = useDerivedValue(() => {
    const x = handlerOffsetX.value % computedAnimResult.WL;
    return isNaN(x) ? 0 : x;
  }, [computedAnimResult]);
  useAutoPlay({
    autoPlay,
    autoPlayInterval,
    autoPlayReverse,
    carouselController,
    lockController
  });
  const next = React.useCallback(() => {
    return carouselController.next();
  }, [carouselController]);
  const prev = React.useCallback(() => {
    return carouselController.prev();
  }, [carouselController]);
  const getCurrentIndex = React.useCallback(() => {
    return index.value;
  }, [index]);
  const goToIndex = React.useCallback((i, animated) => {
    carouselController.to(i, animated);
  }, [carouselController]);
  const animatedListScrollHandler = useAnimatedGestureHandler({
    onStart: (_, ctx) => {
      if (lockController.isLock()) return;
      runOnJS(onScrollBegin)();
      ctx.startContentOffsetX = handlerOffsetX.value;
      ctx.currentContentOffsetX = handlerOffsetX.value;
      ctx.start = true;
    },
    onActive: (e, ctx) => {
      if (lockController.isLock() || !ctx.start) return;
      /**
       * `onActive` and `onEnd` return different values of translationX！So that creates a bias！TAT
       * */

      ctx.translationX = e.translationX;

      if (loop) {
        handlerOffsetX.value = ctx.currentContentOffsetX + e.translationX;
        return;
      }

      handlerOffsetX.value = Math.max(Math.min(ctx.currentContentOffsetX + e.translationX, 0), -(data.length - 1) * width);
    },
    onEnd: (e, ctx) => {
      if (lockController.isLock() || !ctx.start) return;
      const translationX = ctx.translationX;

      function _withTimingCallback(num) {
        return withTiming(num, timingConfig, isFinished => {
          if (isFinished) {
            ctx.start = false;
            lockController.unLock();
            runOnJS(onScrollEnd)();
          }
        });
      }

      if (translationX > 0) {
        /**
         * If not loop no , longer scroll when sliding to the start.
         * */
        if (!loop && handlerOffsetX.value >= 0) {
          return;
        }

        lockController.lock();

        if (Math.abs(translationX) + Math.abs(e.velocityX) > width / 2) {
          handlerOffsetX.value = _withTimingCallback(handlerOffsetX.value + width - translationX);
        } else {
          handlerOffsetX.value = _withTimingCallback(handlerOffsetX.value - translationX);
        }

        return;
      }

      if (translationX < 0) {
        /**
         * If not loop , no longer scroll when sliding to the end.
         * */
        if (!loop && handlerOffsetX.value <= -(data.length - 1) * width) {
          return;
        }

        lockController.lock();

        if (Math.abs(translationX) + Math.abs(e.velocityX) > width / 2) {
          handlerOffsetX.value = _withTimingCallback(handlerOffsetX.value - width - translationX);
        } else {
          handlerOffsetX.value = _withTimingCallback(handlerOffsetX.value - translationX);
        }

        return;
      }
    }
  }, [loop, data, lockController, onScrollBegin, onScrollEnd]);
  React.useImperativeHandle(ref, () => {
    return {
      next,
      prev,
      getCurrentIndex,
      goToIndex
    };
  });
  const Layouts = React.useMemo(() => {
    switch (mode) {
      case 'parallax':
        return ({
          index: i,
          children
        }) => /*#__PURE__*/React.createElement(ParallaxLayout, {
          parallaxScrollingOffset: parallaxScrollingOffset,
          parallaxScrollingScale: parallaxScrollingScale,
          computedAnimResult: computedAnimResult,
          width: width,
          handlerOffsetX: offsetX,
          index: i,
          key: i,
          loop: loop
        }, children);

      default:
        return ({
          index: i,
          children
        }) => /*#__PURE__*/React.createElement(CarouselItem, {
          computedAnimResult: computedAnimResult,
          width: width,
          height: height,
          handlerOffsetX: offsetX,
          index: i,
          key: i,
          loop: loop
        }, children);
    }
  }, [loop, mode, computedAnimResult, height, offsetX, parallaxScrollingOffset, parallaxScrollingScale, width]);
  return /*#__PURE__*/React.createElement(PanGestureHandler, {
    onHandlerStateChange: animatedListScrollHandler
  }, /*#__PURE__*/React.createElement(Animated.View, {
    style: [// eslint-disable-next-line react-native/no-inline-styles
    {
      width,
      height,
      flexDirection: 'row',
      position: 'relative'
    }, style]
  }, data.map((item, i) => {
    return /*#__PURE__*/React.createElement(Layouts, {
      index: i,
      key: i
    }, renderItem(item, i));
  })));
}

export default /*#__PURE__*/React.forwardRef(Carousel);
//# sourceMappingURL=Carousel.js.map